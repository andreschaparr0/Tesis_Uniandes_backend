\chapter{Diseño, Arquitectura e Implementación}
\label{chap:diseno-implementacion}

\section{Visión general del sistema}

La aplicación implementada permite que un profesional de recursos humanos cargue hojas de vida en PDF y descripciones de trabajo en texto, las estructure automáticamente mediante modelos de lenguaje y obtenga, en cuestión de segundos, un score de compatibilidad por candidato acompañado de un desglose explicativo por aspectos clave (experiencia, habilidades, educación, entre otros). Detrás de esta interacción sencilla se articula una arquitectura en capas que separa la interfaz de usuario, la lógica de negocio, el motor de recomendación y la persistencia de datos, lo que facilita la trazabilidad de cada decisión y la evolución independiente de los componentes.

Este capítulo describe cómo se materializó la metodología propuesta, desde el diseño de la arquitectura del sistema hasta los aspectos centrales de su implementación. Se parte de una vista global que muestra cómo el usuario interactúa con la aplicación, cómo el frontend se comunica con la API y cómo esta, a su vez, orquesta servicios, núcleo de recomendación y acceso a datos. A continuación se muestra la figura que resume esta arquitectura por capas y servirá como referencia visual a lo largo del capítulo.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{Arquitectura_aplicacion.png}
    \caption{Arquitectura de la aplicación}
    \label{fig:diagram-arquitectura}
\end{figure}

\subsection{Arquitectura general y flujo de usuario}

La arquitectura propuesta sigue un patrón cliente–servidor en el que el usuario de recursos humanos interactúa con un frontend web desarrollado en React. Este frontend consume una API REST construida con FastAPI, encargada de recibir las solicitudes (subir HVs, registrar descripciones de trabajo, lanzar análisis y consultar resultados) y delegar la lógica de negocio a una capa de servicios. Los servicios coordinan dos elementos principales del backend: por un lado, el \emph{core} del sistema, donde se ubican la limpieza de texto, la estructuración basada en modelos de lenguaje (LLM) y el motor de recomendación por aspectos; por otro lado, la capa de datos, compuesta por repositorios y una base de datos SQLite que almacena HVs, descripciones y análisis. De esta forma, el flujo típico es: usuario \(\rightarrow\) frontend \(\rightarrow\) API \(\rightarrow\) servicios \(\rightarrow\) core y datos, y de regreso hacia el usuario con un score final y explicaciones asociadas.

La Figura \ref{fig:diagram-arquitectura} se organiza en cuatro componentes principales. En primer lugar, el \textbf{frontend}, que ofrece la interfaz donde se cargan documentos y se consultan análisis. En el backend, se distinguen tres bloques: (i) la \textbf{capa de aplicación}, que agrupa API y servicios y define los flujos de casos de uso; (ii) la \textbf{capa de datos}, compuesta por repositorios y la base de datos responsable de la persistencia; y (iii) el \textbf{core} de la aplicación, donde residen el pipeline de NLP (limpieza y estructuración) y el motor de recomendación con sus comparadores por aspecto. Esta separación permite razonar sobre el sistema tanto desde la perspectiva de arquitectura de software como desde la perspectiva de flujo de información.

\subsection{Estructura del capítulo}

Para facilitar la lectura, el resto del capítulo se organiza siguiendo la descomposición que sugiere la arquitectura. Primero se presenta en detalle el backend por capas, comenzando por la API y los servicios, continuando con los repositorios y el modelo de datos, despues se profundiza en el core del sistema conectando estos elementos con las decisiones metodológicas descritas en el capítulo anterior. Finalmente, se describe el rol del frontend y su interacción con la API, resaltando cómo se materializa el flujo de usuario en la interfaz y cómo se presentan los resultados de manera que apoyen la toma de decisiones en el primer filtro de selección.

\section{Vista general del backend}

El backend del sistema implementa la lógica de negocio necesaria para transformar documentos en estructuras comparables, ejecutar el motor de recomendación y almacenar de forma persistente los resultados. Está organizado en capas bien definidas que separan el API y la logica de negocio (servicios), el núcleo de procesamiento (limpieza, estructuración y comparación) y el acceso a datos (repositorios y base de datos). Esta separación favorece la mantenibilidad y permite razonar sobre cada responsabilidad de forma aislada, al tiempo que facilita la reutilización de componentes en distintos flujos de la aplicación.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Arquitectura_aplicacion_backend.png}
    \caption{Arquitectura por capas del backend}
    \label{fig:arquitectura_backend}
\end{figure}
Desde el punto de vista de la comunicación interna, la API recibe las solicitudes provenientes del frontend y delega en la capa de servicios tareas como procesar un nuevo CV, registrar una oferta o ejecutar un análisis. Los servicios, a su vez, invocan el core para limpiar y estructurar texto, o para calcular puntajes de compatibilidad, y utilizan los repositorios para leer y escribir en la base de datos SQLite. Como se aprecia en la Figura \ref{fig:arquitectura_backend}, las llamadas fluyen de API a servicios, de servicios al core, y de allí a los repositorios, cerrando el ciclo al devolver al usuario información enriquecida (scores, breakdowns y resúmenes) a través de la misma API.

\section{Capa de aplicación: API y servicios}

\subsection{Introducción a la capa de aplicación}
La capa de aplicación es el punto de entrada del backend: recibe las peticiones HTTP provenientes del frontend, las valida y las traduce en operaciones de negocio concretas. En ella se ubican la API, implementada con FastAPI, y la capa de servicios, responsable de coordinar el pipeline de limpieza, estructuración, recomendación y acceso a datos. De esta forma, la lógica de negocio queda encapsulada en servicios reutilizables, mientras que la API se limita a exponer endpoints bien definidos y a gestionar aspectos transversales como serialización, manejo de errores y documentación. En la siguiente Figura \ref{fig:capa_de_aplicacion_en_backend} se muestra cual es la capa de aplicación en el backend.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Arquitectura_backend_capa_de_aplicacion.png}
    \caption{Capa de aplicación en el backend}
    \label{fig:capa_de_aplicacion_en_backend}
\end{figure}


En términos de flujo, como se puede observar en la siguiente Figura \ref{fig:Capa_de_aplicacion} , el frontend invoca los endpoints de la API para manejar todo lo referente a las HV, descripciones o análisis; la API delega exclusivamente en el servicio correspondiente (CVService, JobService, RecommendationService o AnalysisService), el cual encapsula toda la lógica de orquestación. Es el servicio quien invoca al core para el procesamiento y quien interactúa con los repositorios para la persistencia de datos. Las figuras de secuencia incluidas en el apéndice de figuras (Figuras \ref{fig:seq-subir-cv}, \ref{fig:seq-crear-job} y \ref{fig:seq-analizar}) ilustran estos flujos paso a paso para los casos de uso principales.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Capa_de_aplicacion.png}
    \caption{Arquitectura de la capa de aplicación}
    \label{fig:Capa_de_aplicacion}
\end{figure}
\subsection{API REST: endpoints y tecnologías}

La API se implementó utilizando FastAPI sobre Python 3.11, aprovechando su soporte para tipado estático y generación automática de documentación. El servidor de desarrollo se levanta con Uvicorn, exponiendo la aplicación en local, mientras que la configuración de CORS permite el acceso controlado desde el cliente web. Adicionalmente, la documentación interactiva detallada de todos los endpoints, incluyendo esquemas de entrada y salida, se genera automáticamente y puede consultarse en tiempo real accediendo a la ruta \texttt{/docs} del servidor (por defecto \texttt{http://localhost:8000/docs}).

Para estructurar la comunicación, los endpoints se agrupan por recurso funcional como se ilustra en la Figura \ref{fig:Figura_API}. Esta organización facilita la mantenibilidad y permite que cada controlador se especialice en un tipo de entidad. A continuación, se describen los grupos principales de endpoints mostrados en el diagrama, cuyo detalle técnico completo (parámetros y respuestas) se encuentra documentado en el Apéndice \ref{app:api-docs}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Figura_API.png}
    \caption{Diseño de la API}
    \label{fig:Figura_API}
\end{figure}

\subsubsection*{Gestión de Hojas de Vida (CVs)}
El componente \texttt{CV\_Endpoint} agrupa las operaciones para la administración del ciclo de vida de las hojas de vida. Su función principal es la carga de documentos (\texttt{crear\_cv}), donde el sistema recibe un archivo PDF, extrae su contenido y lo procesa. Adicionalmente, expone métodos para listar todos los candidatos (\texttt{listar\_cvs}), consultar el detalle de uno específico (\texttt{obtener\_cv}), buscar por nombre (\texttt{buscar\_cvs}) y eliminar registros (\texttt{eliminar\_cv}). Puede consultar el detalle técnico de estos endpoints en el Apéndice \ref{sec:api-hvs}.

\subsubsection*{Gestión de Descripciones de Trabajo (Jobs)}
El componente \texttt{Job\_Endpoint} gestiona las ofertas laborales de manera análoga. Permite registrar nuevas descripciones mediante texto plano (\texttt{crear\_job}), las cuales son procesadas para estructurar requisitos. Las operaciones de consulta (\texttt{listar\_jobs}, \texttt{obtener\_job}, \texttt{buscar\_jobs}) facilitan la recuperación de información, mientras que \texttt{eliminar\_job} permite la gestión del ciclo de vida de la vacante. Puede consultar el detalle técnico de estos endpoints en el Apéndice \ref{sec:api-jobs}.

\subsubsection*{Análisis y Estadísticas}
El componente \texttt{Analysis\_Endpoint} actúa como el núcleo funcional donde converge la información. Su método principal, \texttt{analizar}, desencadena la comparación entre una HV y un Job. Este módulo también ofrece endpoints para consultar el historial (\texttt{listar\_analyses}), obtener detalles específicos (\texttt{obtener\_analysis}), generar rankings de mejores candidatos (\texttt{analyses\_por\_job} o top candidatos) y visualizar métricas generales del sistema (\texttt{estadisticas}). Puede consultar el detalle técnico de estos endpoints en el Apéndice \ref{sec:api-analysis}.

Cada endpoint está diseñado bajo el patrón de \emph{application services}, delegando la totalidad del procesamiento y la persistencia a la capa de servicios. Su responsabilidad se limita a validar la estructura de la petición HTTP, invocar el método de servicio adecuado y transformar la respuesta de negocio en una respuesta HTTP con los códigos de estado estándar.

\subsection{Servicios y lógica de negocio}

La capa de servicios sigue un patrón de \emph{application services} que centraliza la lógica de negocio, orquestando la interacción entre los componentes del sistema. Como se ilustra en la Figura \ref{fig:FiguraServices}, estos servicios actúan como intermediarios que coordinan el acceso a datos y la ejecución de procesos del núcleo, garantizando que la API permanezca desacoplada de la implementación subyacente.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Figura_Services.png}
    \caption{Componentes de la capa de servicios}
    \label{fig:FiguraServices}
\end{figure}

El backend se estructura en cuatro servicios principales, cada uno con responsabilidades delimitadas:

\begin{itemize}
  \item \textbf{CVService}: Gestiona el ciclo de vida de las hojas de vida. Sus funciones principales incluyen procesar archivos PDF (\texttt{process\_cv\_from\_file}) interactuando con el nucleo y administrar la persistencia de datos (creación, búsqueda y eliminación) interactuando directamente con la capa de repositorios.
  
  \item \textbf{JobService}: Centraliza la lógica relacionada con las descripciones de trabajo. Coordina la estructuración de texto plano mediante IA (\texttt{process\_job\_from\_text}) interactuando con el core y gestiona todas las operaciones CRUD sobre las ofertas laborales, asegurando que los datos almacenados cumplan con el esquema requerido.

  \item \textbf{AnalysisService}: Administra el historial y consulta de resultados. Este servicio se encarga de persistir los análisis generados, recuperar detalles específicos, y ofrecer consultas agregadas como rankings de candidatos  o estadísticas globales del sistema, sirviendo como fuente de verdad para la visualización de datos.

  \item \textbf{RecommendationService}: Encapsula la inteligencia del sistema. Su método principal (\texttt{analyze}) orquesta el motor de recomendación (\texttt{RecommendationEngine}) para comparar los datos estructurados de una HV y un Job. Este servicio es responsable de calcular los puntajes de compatibilidad y generar los desgloses explicativos, delegando la persistencia del resultado final al \texttt{AnalysisService}.
\end{itemize}

Este diseño modular facilita la mantenibilidad y las pruebas unitarias, ya que cada servicio puede aislarse para verificar su lógica de orquestación independientemente de la interfaz HTTP o de la base de datos.
\section{Capa de Datos y Persistencia}
\label{sec:capa-datos}

\subsection{Introducción a la capa de datos}
Esta sección detalla la capa encargada de garantizar la persistencia y consistencia de la información dentro del sistema. Como se aprecia en la Figura \ref{fig:capa_de_datos_en_backend}, donde se resalta en amarillo el componente de datos, esta capa fundamenta el almacenamiento del sistema. La arquitectura se basa en el patrón \textit{Repository}, el cual actúa como una colección en memoria para objetos del dominio, abstrayendo los detalles de implementación de la base de datos subyacente. En este caso, se emplea SQLite como motor de almacenamiento debido a su ligereza y suficiencia para el alcance del prototipo, gestionado a través de \texttt{SQLAlchemy} como ORM (Object-Relational Mapper). Esta combinación permite manipular los datos utilizando clases y objetos de Python, facilitando la evolución del esquema sin atar la lógica de negocio a consultas SQL específicas.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Arquitectura_backend_capa_de_datos.png}
    \caption{Capa de datos en el backend}
    \label{fig:capa_de_datos_en_backend}
\end{figure}

\subsection{Implementación de Repositorios y Flujo de Persistencia}
\subsection{Modelo de Datos e Implementación de Persistencia}

El diseño de la capa de datos se fundamenta en un modelo relacional simple pero robusto, representado en la Figura \ref{fig:er-modelo}, que permite almacenar de forma estructurada la información clave del proceso de selección. El esquema consta de tres entidades principales: \textbf{CVS}, que almacena los perfiles de los candidatos; \textbf{JOBS}, que contiene las descripciones de las vacantes; y \textbf{ANALYSES}, una tabla intermedia que materializa la relación muchos a muchos entre candidatos y vacantes, registrando los resultados detallados de cada evaluación de compatibilidad.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{ModeloEntidadRelacion.png}
    \caption{Modelo de datos (ER)}
    \label{fig:er-modelo}
\end{figure}

Para llevar este modelo a la implementación, se emplea un diseño que desacopla la definición de las entidades de su lógica de manipulación, tal como se introdujo en la Figura \ref{fig:capa_de_datos_en_backend}. Como se detalla en el Apéndice (Figura \ref{fig:DetallesImplementacionDatos}), se utilizan clases de modelo (\textit{Models}) que heredan de la base declarativa de SQLAlchemy para mapear los atributos definidos en el diagrama ER a columnas físicas de la base de datos SQLite.

La manipulación de estos datos se delega a los repositorios, que actúan como gestores de transacciones. El flujo de persistencia, ilustrado en la Figura \ref{fig:flujo_persistencia_analysis}, sigue una secuencia rigurosa para asegurar la integridad referencial: cuando un servicio solicita guardar un análisis, el repositorio transforma los datos en una instancia del modelo ORM, gestiona la sesión de la base de datos y ejecuta la confirmación (\textit{commit}), retornando finalmente el objeto con su identificador persistido para su uso en las capas superiores.

\section{Core del sistema}
\subsection{Introducción al core de la aplicación}
El \textit{Core} del sistema representa el componente central donde reside la inteligencia de la aplicación, separado lógica y funcionalmente de las capas de servicio y persistencia. Como se aprecia en la Figura \ref{fig:arquitectura_backe_core}, este núcleo agrupa los módulos de procesamiento intensivo en dos grandes motores: el motor de estructuración, encargado de interpretar y estandarizar la información no estructurada de documentos y textos; y el motor de recomendación, que orquesta los algoritmos de comparación para evaluar la compatibilidad entre candidatos y vacantes. Esta disposición permite que el procesamiento cognitivo y el cálculo de similitudes evolucionen de forma independiente a la lógica de control de la API.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Arquitectura_backend_core.png}
    \caption{Core de la aplicación en el backend}
    \label{fig:arquitectura_backe_core}
\end{figure}

\section{IA: Pion el nombre a esta section de la estructuracion}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{DiagramaEstructuraciones.png}
    \caption{Enter Caption}
    \label{fig:placeholder}
\end{figure}